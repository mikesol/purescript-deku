// Generated by purs version 0.14.4
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad = require("../Control.Monad/index.js");
var Control_Semigroupoid = require("../Control.Semigroupoid/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_BooleanAlgebra = require("../Data.BooleanAlgebra/index.js");
var Data_Bounded = require("../Data.Bounded/index.js");
var Data_CommutativeRing = require("../Data.CommutativeRing/index.js");
var Data_DivisionRing = require("../Data.DivisionRing/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Field = require("../Data.Field/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_NaturalTransformation = require("../Data.NaturalTransformation/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Unit = require("../Data.Unit/index.js");
var Data_Void = require("../Data.Void/index.js");
module.exports = {
    liftA1: Control_Applicative.liftA1,
    pure: Control_Applicative.pure,
    unless: Control_Applicative.unless,
    when: Control_Applicative.when,
    apply: Control_Apply.apply,
    bind: Control_Bind.bind,
    discard: Control_Bind.discard,
    ifM: Control_Bind.ifM,
    join: Control_Bind.join,
    identity: Control_Category.identity,
    ap: Control_Monad.ap,
    liftM1: Control_Monad.liftM1,
    unlessM: Control_Monad.unlessM,
    whenM: Control_Monad.whenM,
    compose: Control_Semigroupoid.compose,
    otherwise: Data_Boolean.otherwise,
    bottom: Data_Bounded.bottom,
    top: Data_Bounded.top,
    recip: Data_DivisionRing.recip,
    eq: Data_Eq.eq,
    notEq: Data_Eq.notEq,
    degree: Data_EuclideanRing.degree,
    div: Data_EuclideanRing.div,
    gcd: Data_EuclideanRing.gcd,
    lcm: Data_EuclideanRing.lcm,
    mod: Data_EuclideanRing.mod,
    "const": Data_Function["const"],
    flip: Data_Function.flip,
    flap: Data_Functor.flap,
    map: Data_Functor.map,
    "void": Data_Functor["void"],
    conj: Data_HeytingAlgebra.conj,
    disj: Data_HeytingAlgebra.disj,
    not: Data_HeytingAlgebra.not,
    mempty: Data_Monoid.mempty,
    between: Data_Ord.between,
    clamp: Data_Ord.clamp,
    compare: Data_Ord.compare,
    comparing: Data_Ord.comparing,
    max: Data_Ord.max,
    min: Data_Ord.min,
    EQ: Data_Ordering.EQ,
    GT: Data_Ordering.GT,
    LT: Data_Ordering.LT,
    negate: Data_Ring.negate,
    sub: Data_Ring.sub,
    append: Data_Semigroup.append,
    add: Data_Semiring.add,
    mul: Data_Semiring.mul,
    one: Data_Semiring.one,
    zero: Data_Semiring.zero,
    show: Data_Show.show,
    unit: Data_Unit.unit,
    absurd: Data_Void.absurd
};
